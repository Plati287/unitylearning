using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// Controlador del jugador que maneja movimiento y vista
public class PlayerController : MonoBehaviour
{
    [Header("Configuración de Movimiento")]
    public float moveSpeed = 5f; // Velocidad de movimiento del jugador

    [Header("Configuración de Cámara")]
    public Vector2 sensibility = new Vector2(2f, 2f); // Sensibilidad del ratón (X, Y)

    // Referencias privadas
    private new Transform camera; // Referencia a la cámara del jugador
    private CharacterController characterController; // Controlador de personaje para el movimiento
    private float verticalRotation = 0f; // Almacena la rotación vertical de la cámara

    // Método que se ejecuta al iniciar el juego (una sola vez)
    void Start()
    {
        // Bloquear el cursor al centro de la pantalla para un control FPS
        Cursor.lockState = CursorLockMode.Locked;

        // Buscar la cámara que debe ser un objeto hijo de este objeto
        camera = transform.Find("Camera");

        // Obtener el componente CharacterController del mismo GameObject
        characterController = GetComponent<CharacterController>();

        // Si no existe CharacterController, añadirlo automáticamente
        if (characterController == null)
        {
            characterController = gameObject.AddComponent<CharacterController>();
        }
    }

    // Método que se ejecuta cada frame del juego
    void Update()
    {
        // Manejar el movimiento del jugador
        HandleMovement();

        // Manejar la rotación de la cámara con el ratón
        HandleMouseLook();
    }

    // Método para manejar el movimiento del jugador con WASD
    void HandleMovement()
    {
        // Detectar si las teclas están PRESIONADAS en este frame
        // GetKey() devuelve true MIENTRAS la tecla esté presionada
        bool isMovingForward = Input.GetKey(KeyCode.W);  // Tecla W presionada
        bool isMovingBackward = Input.GetKey(KeyCode.S); // Tecla S presionada
        bool isMovingLeft = Input.GetKey(KeyCode.A);     // Tecla A presionada
        bool isMovingRight = Input.GetKey(KeyCode.D);    // Tecla D presionada

        // Crear vector de movimiento (inicialmente en cero)
        Vector3 moveDirection = Vector3.zero;

        // Solo añadir movimiento hacia adelante si W está presionada
        if (isMovingForward)
        {
            moveDirection += transform.forward; // Añadir dirección hacia adelante
        }

        // Solo añadir movimiento hacia atrás si S está presionada
        if (isMovingBackward)
        {
            moveDirection -= transform.forward; // Restar dirección hacia adelante (ir hacia atrás)
        }

        // Solo añadir movimiento a la derecha si D está presionada
        if (isMovingRight)
        {
            moveDirection += transform.right; // Añadir dirección hacia la derecha
        }

        // Solo añadir movimiento a la izquierda si A está presionada
        if (isMovingLeft)
        {
            moveDirection -= transform.right; // Restar dirección hacia la derecha (ir a la izquierda)
        }

        // Normalizar el vector para evitar movimiento más rápido en diagonal
        // Sin normalizar: W+D = velocidad 1.41x más rápida
        // Con normalizar: W+D = velocidad normal
        if (moveDirection.magnitude > 0)
        {
            moveDirection = moveDirection.normalized;
        }

        // Aplicar la velocidad y el tiempo transcurrido desde el último frame
        // Time.deltaTime asegura que el movimiento sea consistente independientemente del framerate
        Vector3 finalMovement = moveDirection * moveSpeed * Time.deltaTime;

        // Aplicar gravedad simple (hacia abajo)
        // Sin esto, el personaje flotaría en el aire
        finalMovement.y = -9.81f * Time.deltaTime;

        // Mover el personaje usando CharacterController
        // Move() maneja automáticamente las colisiones
        characterController.Move(finalMovement);

        // IMPORTANTE: Si no presionas ninguna tecla, moveDirection será Vector3.zero
        // y el personaje NO se moverá (esto es exactamente lo que queremos)
    }

    // Método para manejar la rotación de la cámara con el ratón
    void HandleMouseLook()
    {
        // Obtener el movimiento del ratón en este frame
        float mouseX = Input.GetAxis("Mouse X"); // Movimiento horizontal del ratón
        float mouseY = Input.GetAxis("Mouse Y"); // Movimiento vertical del ratón

        // Rotación horizontal (girar el cuerpo del jugador izquierda/derecha)
        if (mouseX != 0) // Solo rotar si hay movimiento del ratón
        {
            // Rotar todo el objeto jugador en el eje Y (arriba)
            transform.Rotate(Vector3.up * mouseX * sensibility.x);
        }

        // Rotación vertical (inclinar la cámara arriba/abajo)
        if (mouseY != 0) // Solo rotar si hay movimiento del ratón
        {
            // Restar para invertir el control (movimiento natural de la cámara)
            verticalRotation -= mouseY * sensibility.y;

            // Limitar la rotación vertical entre -70° y +70°
            // Esto evita que la cámara pueda dar vueltas completas
            verticalRotation = Mathf.Clamp(verticalRotation, -70f, 70f);

            // Aplicar la rotación solo a la cámara (no al cuerpo del jugador)
            camera.localEulerAngles = Vector3.right * verticalRotation;
        }
    }
}
